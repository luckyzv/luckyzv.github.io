# DDIA学习简要笔记（1）可靠性、可伸缩性和可维护性


### 数据系统

现在很多系统是数据密集型的，而不是计算密集型，因此CPU很少成为这类应用的瓶颈。更大的问题通常来源于数据量、数据复杂性、数据的变更速度。

主要讨论三个在大多数软件系统中都重要的问题

- 可靠性

系统在一些错误or异常中依然能够正常工作（符合期望的工作）

- 可伸缩性

有合理的办法应对系统的增长（数据量、流量、复杂性）

- 可维护性

许多不同的人在不同的生命周期，都能在当前系统上高效的工作（保持现有行为，适应新的场景）

### 可靠性

人们对于一个东西是否可靠，都有一个直观的想法。人们对可靠软件的典型期望包括：

- 应用程序表现出用户所期望的功能。
- 允许用户犯错，允许用户以出乎意料的方式使用软件。
- 在预期的负载和数据量下，性能满足要求。
- 系统能防止未经授权的访问和滥用。

如果所有这些在一起意味着 “正确工作”，那么可以把可靠性粗略理解为 “即使出现问题，也能继续正确工作”。

造成错误的原因叫做`故障`，能预料并应对故障的系统特性可称为`容错`。在讨论容错时，只有谈论特定类型的错误才有意义（总不能考虑地球毁灭了，怎么容错吧）。

故障不同于失效。`故障`通常定义为系统的一部分状态偏离其标准，而`失效`则是系统作为一个整体停止向用户提供服务。故障的概率不可能降到零，最好设计容错机制以防因故障而导致失效。


尽管比起`阻止错误`，我们通常更倾向于`容忍错误`。但也有预防胜于治疗的情况（比如不存在治疗方法时）。安全问题就属于这种情况。

#### 硬件故障

首先硬件冗余。

其次如果在硬件冗余的基础上进一步引入软件容错机制，那么系统在容忍整个（单台）机器故障的道路上就更进一步了。例如：如果需要重启机器（例如应用操作系统安全补丁），单服务器系统就需要计划停机。而允许机器失效的系统则可以一次修复一个节点，无需整个系统停机。

#### 软件错误

内部的系统性错误，这类错误难以预料。比如微服务情况下，比起硬件故障，系统性错误往往可能造成更多的**系统失效**。

- 接受特定的错误输入，便导致所有应用服务器实例崩溃的 BUG。
- 失控进程会用尽一些共享资源，包括 CPU 时间、内存、磁盘空间或网络带宽。
- 系统依赖的服务变慢，没有响应，或者开始返回错误的响应。
- 级联故障，一个组件中的小故障触发另一个组件中的故障，进而触发更多的故障（雪崩）。

系统性故障没有速效药，但是有很多小办法，例如：仔细考虑系统中的假设和交互；彻底的测试；进程隔离；允许进程崩溃并重启；测量、监控和报警。

#### 人为错误

比如配置错误。

- 更好的设计系统。例如精心设计的抽象、API、管理后台。
- 解耦。提供staging环境or沙箱环境，使用真实数据进行测试。
- 充分的测试。单元测试、集成测试、自动化测试，更多的覆盖`corner case`。
- 允许快速回滚。例如配置快速回滚。
- 监控以及告警。otel监控发出预警信号。
- 良好的管理和培训。

### 可伸缩性

系统今天能可靠运行，并不意味着未来也能够可靠运行。服务`降级`的一个常见原因是负载增加。例如：系统已经从一万个并发用户增长到十万个并发用户。

讨论可伸缩性意味着考虑诸如 “如果系统以特定方式增长，有什么选项可以应对增长？” 和 “如何增加计算资源来处理额外的负载？” 等问题。

#### 描述负载

负载可以用一些称为 **负载参数（load parameters）** 的数字来描述。参数的最佳选择取决于系统架构，它可能是每秒向 Web 服务器发出的请求、数据库中的读写比率、聊天室中同时活跃的用户数量、缓存命中率或其他东西。除此之外，也许平均情况对你很重要，也许你的瓶颈是少数极端场景。

具体可以参考原文中[推特事例](http://ddia.vonng.com/#/ch1?id=%e6%8f%8f%e8%bf%b0%e8%b4%9f%e8%bd%bd)。这里主要介绍了推特的伸缩性挑战不是主要来自推特量，而是来源于**扇出**。推文如何同步到其他用户主页时间线上

推特发布推文最终走向了：大多数用户的推文会被写入到其粉丝的主页时间线缓存中，少数拥有海量粉丝的用户，并不会直接写入到其粉丝的主页时间线缓存，而是当用户读取主页时间线时，分别读取主页时间线缓存以及主动获取该用户关注的每位名流（拥有海量粉丝）的推文，然后合并两者。

#### 描述性能

对于 Hadoop 这样的批处理系统，通常关心的是**吞吐量**，即每秒可以处理的记录数量，或者在特定规模数据集上运行作业的总时间。对于在线系统，通常更重要的是服务的 **响应时间**，即客户端发送请求到接收响应之间的时间。

##### 延迟和响应时间

**延迟（latency）** 和 **响应时间（response time）** 经常用作同义词，但实际上它们并不一样。响应时间是客户所看到的，除了实际处理请求的时间（ **服务时间（service time）** ）之外，还包括网络延迟和排队延迟。延迟是某个请求等待处理的 **持续时长**，在此期间它处于 **休眠（latent）** 状态，并等待服务。

即使不断重复发送同样的请求，每次得到的响应时间也都会略有不同。因此我们需要将响应时间视为一个可以测量的数值 **分布**，而不是单个数值。

通常平均响应时间并不能够告诉你有多少用户实际上经历了这个延迟。使用**百分位点**是一个更好的建议。如果将响应时间列表按最快到最慢排序，那么 **中位数** 就在正中间：举个例子，如果你的响应时间中位数是 200 毫秒，这意味着一半请求的返回时间少于 200 毫秒，另一半比这个要长。中位数也被称为第 50 百分位点，有时缩写为 p50。注意中位数是关于单个请求的

为了弄清异常值有多糟糕，可以看看更高的百分位点，例如第 95、99 和 99.9 百分位点（缩写为 p95，p99 和 p999）。它们意味着 95%、99% 或 99.9% 的请求响应时间要比该阈值快，例如：如果第 95 百分位点响应时间是 1.5 秒，则意味着 100 个请求中的 95 个响应时间快于 1.5 秒，而5个响应时间超过1.5秒。

由于服务器只能并行处理少量的事务（如受其 CPU 核数的限制），所以只要有少量缓慢的请求就能阻碍后续请求的处理，这种效应有时被称为 **头部阻塞** 。例如压测时，要不断发送请求而不是等待上一个响应完成，如果客户端在发送下一个请求之前等待先前的请求完成，这种行为会产生人为排队的效果，会使得测量结果产生误差。

响应时间的高百分位点（也称为 **尾部延迟**）非常重要，因为它们直接影响用户的服务体验。需要注意的是，**当一个请求需要多个后端请求时，单个后端慢请求就会拖慢整个终端用户的请求**

#### 应对负载的方法

上面已经讨论了描述负载的参数（例如请求数、命中率）和衡量性能的指标（例如百分位点）。然后我们就可以讨论可伸缩性了：当负载参数增加时，如何保持良好的性能？

人们经常讨论 **纵向伸缩**（也称为垂直伸缩，转向更强大的机器）和 **横向伸缩**（也称为水平伸缩，将负载分布到多台小机器上）之间的对立。现实世界中的优秀架构需要将这两种方法务实地结合，因为使用几台足够强大的机器可能比使用大量的小型虚拟机更简单也更便宜。

有些系统是 **弹性** 的，这意味着可以在检测到负载增加时自动增加计算资源，而其他系统则是手动伸缩（人工分析并决定向系统添加更多的机器）。如果负载 **极难预测**，则弹性系统可能很有用，但手动伸缩系统更简单，并且意外操作可能会更少。

大规模的系统架构通常是应用特定的 —— 没有一招鲜吃遍天的通用可伸缩架构。应用的问题可能是读取量、写入量、要存储的数据量、数据的复杂度、响应时间要求、访问模式或者所有问题的大杂烩。举个例子，用于处理每秒十万个请求（每个大小为 1 kB）的系统与用于处理每分钟 3 个请求（每个大小为 2GB）的系统看上去会非常不一样，尽管两个系统有同样的数据吞吐量。

### 可维护性

众所周知，软件的大部分开销并不在最初的开发阶段，而是在持续的维护阶段，包括修复漏洞、保持系统正常运行、适配新的平台、为新的场景进行修改、偿还技术债、添加新的功能等等。

但是我们可以，也应该以这样一种方式来设计软件：在设计之初就尽量考虑尽可能减少维护期间的痛苦，从而避免自己的软件系统变成遗留系统。

#### 可操作性：人生苦短，关爱运维

便于运维团队保持系统平稳运行。

#### 简单性：管理复杂度

**复杂度**有各种可能的症状，例如：状态空间激增、模块间紧密耦合、纠结的依赖关系、不一致的命名和术语、解决性能问题的 Hack、需要绕开的特例等等。

降低复杂度能极大地提高软件的可维护性，因此简单性应该是构建系统的一个关键目标。

用于消除 **额外复杂度** 的最好工具之一是 **抽象**。一个好的抽象可以将大量实现细节隐藏在一个干净，简单易懂的外观下面。一个好的抽象也可以广泛用于各类不同应用。比起重复造很多轮子，重用抽象不仅更有效率，而且有助于开发高质量的软件。抽象组件的质量改进将使所有使用它的应用受益。

例如SQL就是一种抽象，他隐藏了复杂的磁盘/内存数据结构以及不一致性等等。

#### 可演化性：拥抱变化

需求，永远处于常态的变化中。在组织流程方面， **敏捷** 工作模式为适应变化提供了一个框架。敏捷社区还开发了对在频繁变化的环境中开发软件很有帮助的技术工具和模式，如 **测试驱动开发（TDD, test-driven development）** 和 **重构（refactoring）** 。



### 小结

一个应用必须满足各种需求才称得上有用。有一些 **功能需求**（即它应该做什么，比如允许以各种方式存储，检索，搜索和处理数据）以及一些 **非功能性需求**（即通用属性，例如安全性、可靠性、合规性、可伸缩性、兼容性和可维护性）。

**可靠性** 意味着即使发生故障，系统也能正常工作，容错机制可以隐藏一些故障。

**可伸缩性**意味着即使在负载增加的情况下也有保持性能的策略。

**可维护性** 有许多方面，但实质上是关于工程师和运维团队的生活质量的。良好的抽象可以帮助降低复杂度，并使系统易于修改和适应新的应用场景。良好的可操作性意味着对系统的健康状态具有良好的可见性，并拥有有效的管理手段。


---

> 作者:   
> URL: https://luckyzv.github.io/2023/ddia1/  

